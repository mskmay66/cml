{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>cmlattice provides a python implementation of various types of coupled map lattices. A coupled map lattice, or CML, is a dynamic system that models the behavior of nonlinear systems.</p> <p>This package contains several different models, all of which can be broadly described as cmls:</p> <ul> <li>A standard CML with logistic state function,</li> <li>The CML model primarily studied by Kaneko<sup>1</sup>,</li> <li>The Rulkov Map<sup>2</sup></li> </ul>"},{"location":"#a-standard-cml","title":"A Standard CML","text":""},{"location":"#a-coupled-kaneko-lattice","title":"A Coupled Kaneko Lattice","text":""},{"location":"#an-uncoupled-rulkov-lattice","title":"An Uncoupled Rulkov Lattice","text":""},{"location":"#chaos","title":"Chaos","text":"<p>These models are particularly useful in studying choatic, dynamic systems. For example, in one dimension choosing an r parameter of greater than 3.57 for a standard lattice will behave choatically.</p>"},{"location":"#citations","title":"Citations","text":"<ol> <li> <p>Kunihiko Kaneko, Period-Doubling of Kink-Antikink Patterns, Quasiperiodicity in Antiferro-Like Structures and Spatial Intermittency in Coupled Logistic Lattice: Towards a Prelude of a \u201cField Theory of Chaos\u201d, Progress of Theoretical Physics, Volume 72, Issue 3, September 1984, Pages 480\u2013486, https://doi.org/10.1143/PTP.72.480\u00a0\u21a9</p> </li> <li> <p>N.F. Rulkov (2001). \"Regularization of Synchronized Chaotic Bursts\". Physical Review Letters. 86 (1): 183\u2013186. arXiv:nlin/0011028. Bibcode:2001PhRvL..86..183R. doi:10.1103/physrevlett.86.183. PMID 11136124. S2CID 7016788\u00a0\u21a9</p> </li> </ol>"},{"location":"cml/","title":"CoupledMapLattice","text":"<p>An implementation of a coupled map lattice (CML) model. Used as a base class for other CML models.</p> <p>Attributes:     n (int): The size of the lattice.     r (float): The parameter for the map function.     epsilion (float): The coupling strength.     state (np.ndarray): The current state of the lattice.     history (list[np.ndarray]): The history of the lattice states.     time (int): The current time step.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>class CoupledMapLattice:\n    \"\"\"An implementation of a coupled map lattice (CML) model.\n    Used as a base class for other CML models.\n\n    Attributes:\n        n (int): The size of the lattice.\n        r (float): The parameter for the map function.\n        epsilion (float): The coupling strength.\n        state (np.ndarray): The current state of the lattice.\n        history (list[np.ndarray]): The history of the lattice states.\n        time (int): The current time step.\n    \"\"\"\n\n    def __init__(self, n: int, r: float, epsilon: float = 1) -&gt; None:\n        self.n = n\n        self.r = r\n        self.epsilon = epsilon\n        self.state = self.init_state()\n        self.history = [self.state]\n        self.time = 0\n\n    def __repr__(self) -&gt; str:\n        return f\"CoupledMapLattice(n={self.n}, r={self.r}, epsilion={self.epsilon})\"\n\n    def init_state(self) -&gt; np.ndarray:\n        \"\"\"Initializes the state of the lattice.\"\"\"\n        return np.random.uniform(0, 1, (self.n, self.n))\n\n    @property\n    def state(self) -&gt; np.ndarray:\n        \"\"\"Returns the current state of the lattice.\"\"\"\n        return self._state.copy()\n\n    @state.setter\n    def state(self, value: np.ndarray) -&gt; None:\n        \"\"\"Sets the state of the lattice.\n        Args:\n            value (np.ndarray): The new state of the lattice.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise ValueError('State must be a numpy array.')\n        if value.ndim != 2:\n            raise ValueError('State must be a 2D array.')\n        if value.dtype != np.float64:\n            raise ValueError('State must be a float64 array.')\n\n        if value.shape != (self.n, self.n):\n            raise ValueError(f\"State must be of shape ({self.n}, {self.n}).\")\n        self._state = value\n\n    @property\n    def history(self) -&gt; list[np.ndarray]:\n        \"\"\"Returns the history of the lattice.\"\"\"\n        return self._history.copy()\n\n    @history.setter\n    def history(self, value: list[np.ndarray]) -&gt; None:\n        \"\"\"Sets the history of the lattice.\n        Args:\n            value (List[np.ndarray]): The new history of the lattice.\n        \"\"\"\n        if not isinstance(value, list):\n            raise ValueError('History must be a list.')\n        if not all(isinstance(x, np.ndarray) for x in value):\n            raise ValueError('All elements in history must be numpy arrays.')\n\n        self._history = value\n\n    def append_history(self, value: np.ndarray) -&gt; None:\n        \"\"\"Appends a new state to the history of the lattice.\n        Args:\n            value (np.ndarray): The new state to append.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise ValueError('Value must be a numpy array.')\n        self._history.append(value)\n\n    def state_function(self, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Applies a function to the state of the lattice.\n        Args:\n            x (np.ndarray): The input array.\n\n        Returns:\n            np.ndarray: The output array after applying the function.\n        \"\"\"\n        return self.r * x * (1 - x)\n\n    def update(self) -&gt; None:\n        \"\"\"Updates the state of the lattice.\n        If `coupled` is True, the update is coupled.\n        \"\"\"\n        if self.epsilon &lt; 1:\n            self._update_coupled()\n        else:\n            self._update_independent()\n        self.append_history(self.state)\n        self.time += 1\n\n    def _update_coupled(self) -&gt; None:\n        \"\"\"Updates the state of the lattice using a coupled map.\"\"\"\n        new_lattice = self.state.copy()\n        for i in range(self.n):\n            left_neighbor = self.state[(i - 1) % self.n]\n            for j in range(self.n):\n                # Apply the coupled map update\n                new_lattice[i, j] = self.epsilon * self.state_function(\n                    self.state[i, j],\n                ) + (1 - self.epsilon) * self.state_function(left_neighbor[j])\n        self.state = new_lattice\n\n    def _update_independent(self) -&gt; None:\n        \"\"\"Updates the state of the lattice using an independent map.\"\"\"\n        self.state = self.state_function(self.state)\n\n    def reset(self) -&gt; None:\n        \"\"\"Resets the lattice to its initial state.\"\"\"\n        self.state = self.init_state()\n        self.history = []\n        self.time = 0\n\n    def simulate(self, steps: int) -&gt; Generator[np.ndarray]:\n        \"\"\"Simulates the lattice for a given number of steps.\n\n        Args:\n            steps (int): The number of steps to simulate.\n\n        Yields:\n            np.ndarray: The state of the lattice at each step.\n        \"\"\"\n        for _ in range(steps):\n            self.update()\n            yield self.state\n</code></pre>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.history","title":"<code>history</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the history of the lattice.</p>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the current state of the lattice.</p>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.append_history","title":"<code>append_history(value)</code>","text":"<p>Appends a new state to the history of the lattice. Args:     value (np.ndarray): The new state to append.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>def append_history(self, value: np.ndarray) -&gt; None:\n    \"\"\"Appends a new state to the history of the lattice.\n    Args:\n        value (np.ndarray): The new state to append.\n    \"\"\"\n    if not isinstance(value, np.ndarray):\n        raise ValueError('Value must be a numpy array.')\n    self._history.append(value)\n</code></pre>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.init_state","title":"<code>init_state()</code>","text":"<p>Initializes the state of the lattice.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>def init_state(self) -&gt; np.ndarray:\n    \"\"\"Initializes the state of the lattice.\"\"\"\n    return np.random.uniform(0, 1, (self.n, self.n))\n</code></pre>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.reset","title":"<code>reset()</code>","text":"<p>Resets the lattice to its initial state.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the lattice to its initial state.\"\"\"\n    self.state = self.init_state()\n    self.history = []\n    self.time = 0\n</code></pre>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.simulate","title":"<code>simulate(steps)</code>","text":"<p>Simulates the lattice for a given number of steps.</p> <p>Args:     steps (int): The number of steps to simulate.</p> <p>Yields:     np.ndarray: The state of the lattice at each step.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>def simulate(self, steps: int) -&gt; Generator[np.ndarray]:\n    \"\"\"Simulates the lattice for a given number of steps.\n\n    Args:\n        steps (int): The number of steps to simulate.\n\n    Yields:\n        np.ndarray: The state of the lattice at each step.\n    \"\"\"\n    for _ in range(steps):\n        self.update()\n        yield self.state\n</code></pre>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.state_function","title":"<code>state_function(x)</code>","text":"<p>Applies a function to the state of the lattice. Args:     x (np.ndarray): The input array.</p> <p>Returns:     np.ndarray: The output array after applying the function.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>def state_function(self, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies a function to the state of the lattice.\n    Args:\n        x (np.ndarray): The input array.\n\n    Returns:\n        np.ndarray: The output array after applying the function.\n    \"\"\"\n    return self.r * x * (1 - x)\n</code></pre>"},{"location":"cml/#cmlattice.cmlattice.CoupledMapLattice.update","title":"<code>update()</code>","text":"<p>Updates the state of the lattice. If <code>coupled</code> is True, the update is coupled.</p> Source code in <code>src/cmlattice/cmlattice.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Updates the state of the lattice.\n    If `coupled` is True, the update is coupled.\n    \"\"\"\n    if self.epsilon &lt; 1:\n        self._update_coupled()\n    else:\n        self._update_independent()\n    self.append_history(self.state)\n    self.time += 1\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Have you found a bug?</p> <ul> <li>Search our github issues to see if your issue is duplicated.</li> <li>If you're unable to find an open issue addressing the problem, open a new one. Be sure to include a title and clear description, as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.</li> </ul> <p>Do you want a new feature?</p> <ul> <li>If you want to add a new feature that is not currently available, please fork the main branch of the repo, make your changes, and submit a pull request.</li> <li>Please use our pre-commit hooks to ensure code style and standards are maintained.</li> </ul> <p>Do you have questions about the source code?</p> <ul> <li>email me @ mskmay66@gmail.com</li> </ul> <p>(ps if you are reading this thank you for your interest and support, thanks for using the package!)</p>"},{"location":"examples/","title":"Examples","text":"<p>For more in-depth examples on using cml for your projects check out the notebooks folder of our git repo. But below is a simple example of using a <code>RulkovLattice</code> in python and bash.</p>"},{"location":"examples/#python","title":"Python","text":"<pre><code># initialize the lattice object\nlattice = RulkovLattice(n=10, r=4, mu=0, sigma=1)\n\n# run a hundred step simulation\nSTEPS = 100\nsim_gen = lattice.simulate(STEPS)\n\n# unpack the generator\nsim = list(sim_gen)\n\n# finally, vizualize your simulation\nviz = Visualization(lattice)\nv = viz.animate()\n</code></pre>"},{"location":"examples/#bash","title":"bash","text":"<pre><code>cml simulate -k rulkov -n 10 -r 4 -e 1 -m 0 -s 1 -t 100\n</code></pre> <p>The Result:</p> <p></p>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install cml\n</code></pre> <p>And then in the relevant files:</p> <pre><code>import cml\n</code></pre> <p>or if you just wanted a particular module, such as the <code>KanekoLattice</code></p> <pre><code>from cml import KanekoLattice\n</code></pre>"},{"location":"kaneko/","title":"KanekoLattice","text":"<p>               Bases: <code>CoupledMapLattice</code></p> <p>An implementation of the Kaneko map.</p> Source code in <code>src/cmlattice/kaneko.py</code> <pre><code>class KanekoLattice(CoupledMapLattice):\n    \"\"\"An implementation of the Kaneko map.\"\"\"\n\n    def __init__(self, n: int, r: float, epsilon: float = 1) -&gt; None:\n        super().__init__(n, r, epsilon)\n\n    def __repr__(self):\n        return f\"KenekoLattice(n={self.n}, r={self.r}, epsilion={self.epsilon})\"\n\n    def update(self):\n        \"\"\"Updates the state of the lattice using the Kaneko map.\"\"\"\n        state = self.state.copy()\n        for i in range(self.n):\n            left_neighbor = state[(i - 1) % self.n]\n            right_neighbor = state[(i + 1) % self.n]\n            for j in range(self.n):\n                # Apply the Kaneko map update\n                state[i, j] = self.epsilon * self.state_function(state[i, j]) + (\n                    self.epsilon / 2\n                ) * (\n                    self.state_function(\n                        left_neighbor[j] +\n                        self.state_function(right_neighbor[j]),\n                    )\n                )\n        self.state = state\n        self.append_history(self.state)\n        self.time += 1\n</code></pre>"},{"location":"kaneko/#cmlattice.kaneko.KanekoLattice.update","title":"<code>update()</code>","text":"<p>Updates the state of the lattice using the Kaneko map.</p> Source code in <code>src/cmlattice/kaneko.py</code> <pre><code>def update(self):\n    \"\"\"Updates the state of the lattice using the Kaneko map.\"\"\"\n    state = self.state.copy()\n    for i in range(self.n):\n        left_neighbor = state[(i - 1) % self.n]\n        right_neighbor = state[(i + 1) % self.n]\n        for j in range(self.n):\n            # Apply the Kaneko map update\n            state[i, j] = self.epsilon * self.state_function(state[i, j]) + (\n                self.epsilon / 2\n            ) * (\n                self.state_function(\n                    left_neighbor[j] +\n                    self.state_function(right_neighbor[j]),\n                )\n            )\n    self.state = state\n    self.append_history(self.state)\n    self.time += 1\n</code></pre>"},{"location":"rulkov/","title":"RulkovLattice","text":"<p>               Bases: <code>CoupledMapLattice</code></p> <p>An implementation of the Rulkov map.</p> <p>The Rulkov map is a coupled map lattice model that exhibits complex behavior, including chaos and synchronization.</p> <p>Attributes:     n (int): The size of the lattice.     r (float): The parameter for the map function.     mu (float): The parameter for the map function.     sigma (float): The parameter for the map function.     epsilion (float): The coupling strength.     state (np.ndarray): The current state of the lattice.     history (list[np.ndarray]): The history of the lattice states.     time (int): The current time step.</p> Source code in <code>src/cmlattice/rulkov.py</code> <pre><code>class RulkovLattice(CoupledMapLattice):\n    \"\"\"An implementation of the Rulkov map.\n\n    The Rulkov map is a coupled map lattice model that exhibits\n    complex behavior, including chaos and synchronization.\n\n    Attributes:\n        n (int): The size of the lattice.\n        r (float): The parameter for the map function.\n        mu (float): The parameter for the map function.\n        sigma (float): The parameter for the map function.\n        epsilion (float): The coupling strength.\n        state (np.ndarray): The current state of the lattice.\n        history (list[np.ndarray]): The history of the lattice states.\n        time (int): The current time step.\n    \"\"\"\n\n    def __init__(\n        self,\n        n: int,\n        r: float,\n        mu: float,\n        sigma: float,\n        epsilon: float = 1,\n    ) -&gt; None:\n        super().__init__(n, r, epsilon)\n        self.mu = mu\n        self.sigma = sigma\n        self.history = [self.state[0]]\n\n    def __repr__(self):\n        return f\"RulkovLattice(n={self.n}, r={self.r}, epsilion={self.epsilon}, mu={self.mu}, sigma={self.sigma})\"\n\n    def init_state(self) -&gt; np.ndarray:\n        \"\"\"Initializes the state of the lattice.\"\"\"\n        return np.random.uniform(0, 1, (2, self.n, self.n))\n\n    @CoupledMapLattice.state.setter\n    def state(self, value: np.ndarray) -&gt; None:\n        \"\"\"Sets the state of the lattice.\n        Args:\n            value (np.ndarray): The new state of the lattice.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise ValueError('State must be a numpy array.')\n        if value.ndim != 3:\n            raise ValueError('State must be a 3D array.')\n        if value.dtype != np.float64:\n            raise ValueError('State must be a float64 array.')\n\n        if value.shape != (2, self.n, self.n):\n            raise ValueError(\n                f\"State must be of shape (2, {self.n}, {self.n}).\",\n            )\n        self._state = value\n\n    def state_function(self, x: np.ndarray, y: np.ndarray = None) -&gt; np.ndarray:\n        \"\"\"Applies the Rulkov map update function to the state of the lattice.\n\n        Args:\n            x (np.ndarray): The input array representing the first state.\n            y (np.ndarray): The input array representing the second state.\n\n        Returns:\n            np.ndarray: The updated state.\n        \"\"\"\n        x_next = (self.r / (1 + x**2)) + y\n        y_next = y - self.mu * (x_next - self.sigma)\n        return np.array([x_next, y_next])\n\n    def _update_coupled(self) -&gt; None:\n        \"\"\"Updates the state of the lattice using the Rulkov map.\"\"\"\n        state = self.state.copy()\n        for i in range(self.n):\n            left_neighbor = state[:, (i - 1) % self.n]\n            right_neighbor = state[:, (i + 1) % self.n]\n            for j in range(self.n):\n                # Apply the Rulkov map update\n                state[:, i, j] = self.epsilon * self.state_function(\n                    state[0, i, j],\n                    state[1, i, j],\n                ) + (self.epsilon / 2) * (\n                    self.state_function(left_neighbor[0, j], left_neighbor[1, j]) +\n                    self.state_function(\n                        right_neighbor[0, j], right_neighbor[1, j],\n                    )\n                )\n        self.state = state\n\n    def _update_independent(self) -&gt; None:\n        \"\"\"Updates the state of the lattice using an independent map.\"\"\"\n        self.state = self.state_function(self.state[0], self.state[1])\n\n    def update(self):\n        if self.epsilon &lt; 1:\n            self._update_coupled()\n        else:\n            self._update_independent()\n\n        assert self.state[0].shape == (\n            self.n, self.n,\n        ), 'The shape is not correct'\n        self.append_history(self.state[0])\n        self.time += 1\n</code></pre>"},{"location":"rulkov/#cmlattice.rulkov.RulkovLattice.init_state","title":"<code>init_state()</code>","text":"<p>Initializes the state of the lattice.</p> Source code in <code>src/cmlattice/rulkov.py</code> <pre><code>def init_state(self) -&gt; np.ndarray:\n    \"\"\"Initializes the state of the lattice.\"\"\"\n    return np.random.uniform(0, 1, (2, self.n, self.n))\n</code></pre>"},{"location":"rulkov/#cmlattice.rulkov.RulkovLattice.state","title":"<code>state(value)</code>","text":"<p>Sets the state of the lattice. Args:     value (np.ndarray): The new state of the lattice.</p> Source code in <code>src/cmlattice/rulkov.py</code> <pre><code>@CoupledMapLattice.state.setter\ndef state(self, value: np.ndarray) -&gt; None:\n    \"\"\"Sets the state of the lattice.\n    Args:\n        value (np.ndarray): The new state of the lattice.\n    \"\"\"\n    if not isinstance(value, np.ndarray):\n        raise ValueError('State must be a numpy array.')\n    if value.ndim != 3:\n        raise ValueError('State must be a 3D array.')\n    if value.dtype != np.float64:\n        raise ValueError('State must be a float64 array.')\n\n    if value.shape != (2, self.n, self.n):\n        raise ValueError(\n            f\"State must be of shape (2, {self.n}, {self.n}).\",\n        )\n    self._state = value\n</code></pre>"},{"location":"rulkov/#cmlattice.rulkov.RulkovLattice.state_function","title":"<code>state_function(x, y=None)</code>","text":"<p>Applies the Rulkov map update function to the state of the lattice.</p> <p>Args:     x (np.ndarray): The input array representing the first state.     y (np.ndarray): The input array representing the second state.</p> <p>Returns:     np.ndarray: The updated state.</p> Source code in <code>src/cmlattice/rulkov.py</code> <pre><code>def state_function(self, x: np.ndarray, y: np.ndarray = None) -&gt; np.ndarray:\n    \"\"\"Applies the Rulkov map update function to the state of the lattice.\n\n    Args:\n        x (np.ndarray): The input array representing the first state.\n        y (np.ndarray): The input array representing the second state.\n\n    Returns:\n        np.ndarray: The updated state.\n    \"\"\"\n    x_next = (self.r / (1 + x**2)) + y\n    y_next = y - self.mu * (x_next - self.sigma)\n    return np.array([x_next, y_next])\n</code></pre>"},{"location":"visualization/","title":"Visualization","text":"<p>A class for visualizing the state of a Coupled Map Lattice (CML).</p> Source code in <code>src/cmlattice/viz.py</code> <pre><code>class Visualization:\n    \"\"\"A class for visualizing the state of a Coupled Map Lattice (CML).\"\"\"\n\n    def __init__(self, lattice: CoupledMapLattice) -&gt; None:\n        self.lattice = lattice\n\n    @property\n    def lattice(self) -&gt; CoupledMapLattice:\n        \"\"\"Returns the current lattice.\"\"\"\n        return self._lattice\n\n    @lattice.setter\n    def lattice(self, value: CoupledMapLattice) -&gt; None:\n        \"\"\"Sets the lattice to the given value.\n        Args:\n            value (CoupledMapLattice): The new lattice.\n        \"\"\"\n        if not isinstance(value, CoupledMapLattice):\n            raise ValueError(\n                'lattice must be an instance of CoupledMapLattice.',\n            )\n\n        assert (\n            len(\n                value.history,\n            )\n            &gt; 1\n        ), 'History must contain at least two elements.'\n        assert len(np.array(value.history).shape) &lt;= 3, ('Histroy must be 2D.')\n\n        self._lattice = value\n\n    def animate(self, show: bool = False, save: bool = True) -&gt; animation.FuncAnimation:\n        \"\"\"Vizulizes the simulation of the lattice over time.\n        This method creates an animation of the lattice's state over time\n        and saves it as a GIF file. The animation shows the activation\n        of the lattice's neurons at each time step.\n\n        Args:\n            show (bool): Whether to show the plot immediately.\n                Defaults to False.\n\n        Returns:\n            animation.FuncAnimation: The animation object.\n\n        Raises:\n            AssertionError: If the lattice is not a CoupledMapLattice\n                or if the history does not contain at least two elements.\n        \"\"\"\n        self.lattice = self.lattice\n        self.fig, self.ax = plt.subplots()\n        return self._animate(frames=len(self.lattice.history), show=show, save=save)\n\n    def show_nueron(self, nueron: tuple[int]) -&gt; None:\n        \"\"\"Shows the activation over time of a single neuron.\n        Args:\n            nueron (int): The index of the neuron to visualize.\n\n        Raises:\n            AssertionError: If the lattice is not a CoupledMapLattice\n                or if the history does not contain at least two elements.\n        \"\"\"\n        self.fig, self.ax = plt.subplots()\n        hist = np.array(self.lattice.history)\n        self.ax.plot(hist[:, nueron[0], nueron[1]])\n        self.ax.set_title(f\"Neuron {nueron} Activation Over Time\")\n        self.ax.set_xlabel('Time')\n        self.ax.set_ylabel('Activation')\n        plt.show()\n\n    def generate_filename(self) -&gt; str:\n        \"\"\"Generate a filename for the animation based on the current date and time.\n\n        Returns:\n            str: The generated filename.\n        \"\"\"\n        now = datetime.now()\n        return now.strftime('lattice_animation_%Y%m%d_%H%M%S.gif')\n\n    def init_animation(self) -&gt; AxesImage:\n        \"\"\"Initialize the animation.\"\"\"\n        self.ax.clear()\n        self.im = self.ax.imshow(\n            self.lattice.history[0],\n            cmap='plasma',\n            interpolation='nearest',\n            animated=True,\n        )\n        return (self.im,)\n\n    def update(self, i: int) -&gt; AxesImage:\n        \"\"\"Update the visualization for the given frame.\n\n        Args:\n            i (int): The current frame number.\n        \"\"\"\n        self.im.set_array(np.nan_to_num(self.lattice.history[i]))\n\n        self.ax.set_title(f\"Time: {i}\")\n        self.ax.set_xlabel('X-axis')\n        self.ax.set_ylabel('Y-axis')\n        self.ax.set_xticks([])\n        return (self.im,)\n\n    def _animate(self, show: bool, frames: int | None = None, save: bool = True) -&gt; animation.FuncAnimation:\n        \"\"\"Animate the visualization.\n\n        Args:\n            show (bool): Whether to show the plot immediately.\n            frames (Optional[int]): The number of frames to animate. If None, use the length of the history.\n                    Defaults to None.\n\n        Returns:\n            animation.FuncAnimation: The animation object.\n        \"\"\"\n        self.ax.clear()\n        if frames is None:\n            frames = len(self.lattice.history)\n\n        ani = animation.FuncAnimation(\n            self.fig,\n            self.update,\n            frames=frames,\n            init_func=self.init_animation,\n            interval=50,\n            blit=True,\n            repeat_delay=1000,\n        )\n\n        if save:\n            os.makedirs('map_animations', exist_ok=True)\n            filename = self.generate_filename()\n            ani.save(\n                os.path.join('map_animations', filename),\n                writer=PillowWriter(fps=5),\n            )\n\n        if show:\n            plt.show()\n        return ani\n</code></pre>"},{"location":"visualization/#cmlattice.viz.Visualization.lattice","title":"<code>lattice</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the current lattice.</p>"},{"location":"visualization/#cmlattice.viz.Visualization.animate","title":"<code>animate(show=False, save=True)</code>","text":"<p>Vizulizes the simulation of the lattice over time. This method creates an animation of the lattice's state over time and saves it as a GIF file. The animation shows the activation of the lattice's neurons at each time step.</p> <p>Args:     show (bool): Whether to show the plot immediately.         Defaults to False.</p> <p>Returns:     animation.FuncAnimation: The animation object.</p> <p>Raises:     AssertionError: If the lattice is not a CoupledMapLattice         or if the history does not contain at least two elements.</p> Source code in <code>src/cmlattice/viz.py</code> <pre><code>def animate(self, show: bool = False, save: bool = True) -&gt; animation.FuncAnimation:\n    \"\"\"Vizulizes the simulation of the lattice over time.\n    This method creates an animation of the lattice's state over time\n    and saves it as a GIF file. The animation shows the activation\n    of the lattice's neurons at each time step.\n\n    Args:\n        show (bool): Whether to show the plot immediately.\n            Defaults to False.\n\n    Returns:\n        animation.FuncAnimation: The animation object.\n\n    Raises:\n        AssertionError: If the lattice is not a CoupledMapLattice\n            or if the history does not contain at least two elements.\n    \"\"\"\n    self.lattice = self.lattice\n    self.fig, self.ax = plt.subplots()\n    return self._animate(frames=len(self.lattice.history), show=show, save=save)\n</code></pre>"},{"location":"visualization/#cmlattice.viz.Visualization.generate_filename","title":"<code>generate_filename()</code>","text":"<p>Generate a filename for the animation based on the current date and time.</p> <p>Returns:     str: The generated filename.</p> Source code in <code>src/cmlattice/viz.py</code> <pre><code>def generate_filename(self) -&gt; str:\n    \"\"\"Generate a filename for the animation based on the current date and time.\n\n    Returns:\n        str: The generated filename.\n    \"\"\"\n    now = datetime.now()\n    return now.strftime('lattice_animation_%Y%m%d_%H%M%S.gif')\n</code></pre>"},{"location":"visualization/#cmlattice.viz.Visualization.init_animation","title":"<code>init_animation()</code>","text":"<p>Initialize the animation.</p> Source code in <code>src/cmlattice/viz.py</code> <pre><code>def init_animation(self) -&gt; AxesImage:\n    \"\"\"Initialize the animation.\"\"\"\n    self.ax.clear()\n    self.im = self.ax.imshow(\n        self.lattice.history[0],\n        cmap='plasma',\n        interpolation='nearest',\n        animated=True,\n    )\n    return (self.im,)\n</code></pre>"},{"location":"visualization/#cmlattice.viz.Visualization.show_nueron","title":"<code>show_nueron(nueron)</code>","text":"<p>Shows the activation over time of a single neuron. Args:     nueron (int): The index of the neuron to visualize.</p> <p>Raises:     AssertionError: If the lattice is not a CoupledMapLattice         or if the history does not contain at least two elements.</p> Source code in <code>src/cmlattice/viz.py</code> <pre><code>def show_nueron(self, nueron: tuple[int]) -&gt; None:\n    \"\"\"Shows the activation over time of a single neuron.\n    Args:\n        nueron (int): The index of the neuron to visualize.\n\n    Raises:\n        AssertionError: If the lattice is not a CoupledMapLattice\n            or if the history does not contain at least two elements.\n    \"\"\"\n    self.fig, self.ax = plt.subplots()\n    hist = np.array(self.lattice.history)\n    self.ax.plot(hist[:, nueron[0], nueron[1]])\n    self.ax.set_title(f\"Neuron {nueron} Activation Over Time\")\n    self.ax.set_xlabel('Time')\n    self.ax.set_ylabel('Activation')\n    plt.show()\n</code></pre>"},{"location":"visualization/#cmlattice.viz.Visualization.update","title":"<code>update(i)</code>","text":"<p>Update the visualization for the given frame.</p> <p>Args:     i (int): The current frame number.</p> Source code in <code>src/cmlattice/viz.py</code> <pre><code>def update(self, i: int) -&gt; AxesImage:\n    \"\"\"Update the visualization for the given frame.\n\n    Args:\n        i (int): The current frame number.\n    \"\"\"\n    self.im.set_array(np.nan_to_num(self.lattice.history[i]))\n\n    self.ax.set_title(f\"Time: {i}\")\n    self.ax.set_xlabel('X-axis')\n    self.ax.set_ylabel('Y-axis')\n    self.ax.set_xticks([])\n    return (self.im,)\n</code></pre>"}]}